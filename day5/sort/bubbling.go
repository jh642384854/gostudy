package main

import "fmt"

/**
	基本思想：

	给定一个N个元素的数组，冒泡法排序将：
	①、如果元素大小关系不正确，交换这两个数（在本例中为a> b），
	②、比较一对相邻元素（a，b），
	③、重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）
	④、到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。

	冒泡排序分析：
	比较和交换需要一个以常量为界的时间，我们称之为c。
	（标准）Bubble Sort中有两个嵌套循环。
	外循环正好运行N次迭代。 但内部循环运行变得越来越短：

	当 i = 0，（N-1）次迭代（比较和可能交换）时。
	当 i = 1，（N-2）次迭代时，...
	当 i =（N-2）时，1次迭代,
	当 i=（N-1），0迭代.
	因此，总迭代次数=（N-1）+（N-2）+ ... + 1 + 0 = N *（N-1）/ 2（推导）。
	总时间= c * N *（N-1）/ 2 = O（N ^ 2）。

	冒泡排序提前终止：
	冒泡排序实际上是低效的，它的 O(N^2) 时间复杂度。 想象一下，我们有 N = 106 个数字。 即使我们的计算机速度超快，并且可以在1秒内计算108次操作，但冒泡排序仍需要大约100秒才能完成。
	但是，它可以提前终止，例如， 尝试Bubble Sort上面显示的小型升序示例[3,6,11,25,39]，它在O(N)时间结束。
	改进的思路很简单：如果我们通过内部循环完全不交换，这意味着数组已经排序，我们可以在这个点上停止冒泡排序。
	讨论：虽然它使冒泡排序在一般情况下运行得更快，但这种改进的想法并没有改变冒泡排序的 O(N^2) 时间复杂性...为什么？

	冒泡排序属于比较简单的排序，以非递减为例，依次遍历数组，发现a[i]>a[i+1}的情况，就交换a[i],a[i+1]这两个值
	直到没有逆序的数据，完成排序
	可以用两个for循环嵌套实现，外层控制遍历次数，内层用来实现交换

	详细可以参考：https://visualgo.net/zh/sorting
 */

func main() {

	nums := [...]int{9, 8, 6, 4, 2, 7, 1, 3, 0, 5}
	n := 0
	m := 0
	/**
		实现方式1：
		这种实现方式，是每次循环一次就找到数组中的最大值，没循环一次，下次在循环的时候，就会减少一次
		因为有一个元素已经固定了(最大值或是最小值)，就不会在参与循环交换处理
	 */
	for j:=1;j<=len(nums)-1 ;j++  {
		for i:=0;i<len(nums)-j ;i++  {
			if nums[i] > nums[i+1]{
				nums[i],nums[i+1] = nums[i+1],nums[i]
			}
			n++
		}
	}
	//
	/**
		实现方式2：
		进行两层循环，用来进行相邻元素的比较，相邻元素比较后进行位置交换
	 */
	/*num := len(nums)
	for j := 0;j<num ;j++  {
		for i := j+1;i<num ;i++  {
			if nums[j] > nums[i] {
				nums[j],nums[i] = nums[i],nums[j]
 			}
			m++
		}
	}*/
	fmt.Printf("m:%d,n:%d \n",m,n)
	fmt.Println(nums)

}